// -- Model dump before bytecode pipeline
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                curry(mod3::multiply, 10, 4)
              } else {
                if Eq<u64>(key, 3) {
                  curry(mod4::alt_multiply, 10, 5)
                } else {
                  if Eq<u64>(key, 4) {
                    curry(mod3::multiply, 1, 6)
                  } else {
                    if Eq<u64>(key, 5) {
                      curry(test::multiply3, 1, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                          curry(test::multiply3, 10, 4, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                            curry(test::multiply3, 100, 3, 3)
                          } else {
                            if Eq<u64>(key, 9) {
                               move|z: u64| test::multiply3(2, 5, z)
                            } else {
                              if Eq<u64>(key, 10) {
                                 move|x: u64| mod4::alt_multiply(x, 11)
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y);
                                    curry(g, 1, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 = curry(mod3::multiply, 1, 12);
                                       move|x: u64| (h)(x)
                                    }
                                  } else {
                                    {
                                      let i: |u64|u64 = curry(test::multiply3, 10, 2, 2);
                                       move|z: u64| (i)(z)
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let i: u64 = 0;
          {
            let __update_iter_flag: bool = false;
            loop {
              if true {
                if __update_iter_flag {
                  i: u64 = Add<u64>(i, 1)
                } else {
                  __update_iter_flag: bool = true
                };
                if Lt<u64>(i, 14) {
                  {
                    let y: u64 = test::choose_function1(i, 3);
                    if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), 3)) {
                      Tuple()
                    } else {
                      Abort(i)
                    };
                    Tuple()
                  }
                } else {
                  break
                };
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        }
    }
} // end 0x42::test

// -- Sourcified model before bytecode pipeline
module 0x42::mod4 {
    public fun alt_multiply(x: u64, y: u64): u64 {
        x * y
    }
}
module 0x42::mod3 {
    public fun multiply(x: u64, y: u64): u64 {
        x * y
    }
}
module 0x42::mod2 {
    friend 0x42::test;
    friend fun double(x: u64): u64 {
        x * 2
    }
}
module 0x42::mod1 {
    friend 0x42::test;
    friend fun triple(x: u64): u64 {
        x * 3
    }
}
module 0x42::test {
    use 0x42::mod4;
    use 0x42::mod3;
    use 0x42::mod2;
    use 0x42::mod1;
    fun add_mul(x: u64, y: u64, z: u64): u64 {
        z * (x + y)
    }
    fun choose_function1(key: u64, x: u64): u64 {
        let f = if (key == 0) mod2::double else if (key == 1) mod1::triple else if (key == 2) Curry(mod3::multiply, 10, 4) else if (key == 3) Curry(mod4::alt_multiply, 10, 5) else if (key == 4) Curry(mod3::multiply, 1, 6) else if (key == 5) Curry(test::multiply3, 1, 3, 2) else if (key == 6) move |x| mod3::multiply(x, 7) else if (key == 7) Curry(test::multiply3, 10, 4, 2) else if (key == 8) Curry(test::multiply3, 100, 3, 3) else if (key == 9) move |z| multiply3(2, 5, z) else if (key == 10) move |x| mod4::alt_multiply(x, 11) else if (key == 11) {
            let g = move |(x,y)| mod3::multiply(x, y);
            Curry(g, 1, 11)
        } else if (key == 12) {
            let h = Curry(mod3::multiply, 1, 12);
            move |x| h(x)
        } else {
            let i = Curry(test::multiply3, 10, 2, 2);
            move |z| i(z)
        };
        f(x)
    }
    fun multiply3(x: u64, y: u64, z: u64): u64 {
        x * y * z
    }
    public fun test_functions() {
        let i = 0;
        let __update_iter_flag = false;
        while (true) {
            if (__update_iter_flag) i = i + 1 else __update_iter_flag = true;
            if (i < 14) {
                let y = choose_function1(i, 3);
                if (y == (i + 2) * 3) () else abort i;
            } else break;
        };
    }
}


Diagnostics:
error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:39:17
   │
39 │                 mod2::double
   │                 ^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:41:17
   │
41 │                 mod1::triple
   │                 ^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:43:17
   │
43 │                 mod3::multiply(4, _)
   │                 ^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:46:17
   │
46 │                 alt_multiply(x, _)
   │                 ^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:49:17
   │
49 │                 mod3::multiply(_, x)
   │                 ^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:51:17
   │
51 │                 multiply3(_, 3, 2)
   │                 ^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:53:17
   │
53 │                 move |x| mod3::multiply(x, 7)
   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:55:17
   │
55 │                 multiply3(4, _, 2)
   │                 ^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:57:17
   │
57 │                 multiply3(3, 3, _)
   │                 ^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:61:17
   │
61 │                 move |z| multiply3(x, y, z)
   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:64:17
   │
64 │                 move |x| alt_multiply(x, z)
   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:66:25
   │
66 │                 let g = move |x, y| mod3::multiply(x, y);
   │                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:67:17
   │
67 │                 g(_, 11)
   │                 ^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:69:25
   │
69 │                 let h = mod3::multiply(_, 12);
   │                         ^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:70:17
   │
70 │                 move |x| h(x)
   │                 ^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:72:25
   │
72 │                 let i = multiply3(2, _, 2);
   │                         ^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
   ┌─ tests/lambda/storable/doable_func.move:73:17
   │
73 │                 move |z| i(z)
   │                 ^^^^^^^^^^^^^

error: Calls to function values other than inline function parameters not yet supported
   ┌─ tests/lambda/storable/doable_func.move:75:9
   │
75 │         f(x)
   │         ^^^^
